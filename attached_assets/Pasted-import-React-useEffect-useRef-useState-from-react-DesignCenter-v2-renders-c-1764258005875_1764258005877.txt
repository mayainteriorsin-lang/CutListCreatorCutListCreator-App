import React, { useEffect, useRef, useState } from "react";

/**
 * DesignCenter (v2) — renders cabinets array, selection and drag support.
 *
 * Usage:
 * <DesignCenter
 *   cabinets={[{ id: 'c1', widthMm:1200, heightMm:600, xMm:0, yMm:0, shelves:[300,300], shutter:true }]}
 *   onSelect={(id)=>console.log(id)}
 *   onUpdate={(cab)=>console.log('moved', cab)}
 * />
 *
 * - Cabinets coordinates xMm,yMm are relative to the drawing center (0,0) in mm.
 * - The component will compute a scale to fit the largest cabinet(s).
 * - If no cabinets provided, a SAMPLE_CABINET is drawn.
 */

export type Cabinet = {
  id: string;
  widthMm: number;
  heightMm: number;
  xMm: number; // position offset in mm relative to center (positive -> right/down)
  yMm: number;
  shelves?: number[]; // positions in mm from top (e.g. [150,300])
  shutter?: boolean;
};

type Props = {
  cabinets?: Cabinet[];
  onSelect?: (id: string | null) => void;
  onUpdate?: (updated: Cabinet) => void;
};

const SAMPLE_CABINET: Cabinet = {
  id: "sample-1",
  widthMm: 1200,
  heightMm: 600,
  xMm: 0,
  yMm: 0,
  shelves: [200, 400],
  shutter: false,
};

const GRID_STEP_MM = 50;
const MARGIN_MM = 40;

export default function DesignCenter({ cabinets, onSelect, onUpdate }: Props): JSX.Element {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const containerRef = useRef<HTMLDivElement | null>(null);

  // selection + drag state (local only)
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const draggingRef = useRef<{
    id: string | null;
    startPointer?: { x: number; y: number };
    startCabPos?: { xMm: number; yMm: number };
  }>({ id: null });

  // use the provided cabinets or fallback to sample (centered)
  const drawCabinets = (cabinets && cabinets.length > 0 ? cabinets : [SAMPLE_CABINET]).map((c, idx) =>
    ({ ...c })
  );

  useEffect(() => {
    const onResize = () => draw();
    window.addEventListener("resize", onResize);
    const id = window.setTimeout(draw, 60);
    return () => {
      window.clearTimeout(id);
      window.removeEventListener("resize", onResize);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cabinets, selectedId]);

  // pointer events for selection and drag
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const getEventPos = (e: PointerEvent) => {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    };

    const onPointerDown = (e: PointerEvent) => {
      const pos = getEventPos(e);
      const info = hitTest(pos.x, pos.y);
      if (info) {
        // start drag
        draggingRef.current.id = info.id;
        draggingRef.current.startPointer = { x: e.clientX, y: e.clientY };
        draggingRef.current.startCabPos = { xMm: info.cab.xMm, yMm: info.cab.yMm };
        setSelectedId(info.id);
        onSelect?.(info.id);
        (canvas as HTMLCanvasElement).setPointerCapture(e.pointerId);
      } else {
        // clicked empty area -> deselect
        draggingRef.current = { id: null };
        setSelectedId(null);
        onSelect?.(null);
      }
    };

    const onPointerMove = (e: PointerEvent) => {
      if (!draggingRef.current.id) return;
      const start = draggingRef.current.startPointer!;
      const dxPx = e.clientX - start.x;
      const dyPx = e.clientY - start.y;

      // compute mm per px scale used in draw (we recompute here to convert movement)
      const scalePxPerMm = computeScalePxPerMm();
      if (!scalePxPerMm) return;

      const dxMm = dxPx / scalePxPerMm;
      const dyMm = dyPx / scalePxPerMm;
      const id = draggingRef.current.id!;
      const startPos = draggingRef.current.startCabPos!;
      const newCab: Cabinet = {
        ...(drawCabinets.find((c) => c.id === id) || SAMPLE_CABINET),
        xMm: startPos.xMm + dxMm,
        yMm: startPos.yMm + dyMm,
      };
      // call onUpdate so parent can persist movement; but do not mutate local props
      onUpdate?.(newCab);
      // also redraw to show temporary result (parent may also re-provide updated props)
      draw(); // draw will reflect props if parent updates; calling it here ensures visual feedback
    };

    const onPointerUp = (e: PointerEvent) => {
      if (draggingRef.current.id) {
        try {
          (canvas as HTMLCanvasElement).releasePointerCapture(e.pointerId);
        } catch {}
      }
      draggingRef.current = { id: null };
    };

    canvas.addEventListener("pointerdown", onPointerDown);
    window.addEventListener("pointermove", onPointerMove);
    window.addEventListener("pointerup", onPointerUp);

    return () => {
      canvas.removeEventListener("pointerdown", onPointerDown);
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cabinets, selectedId]);

  // compute scale used by the renderer (px per mm)
  function computeScalePxPerMm() {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return null;
    const rect = container.getBoundingClientRect();
    const cssW = Math.max(300, Math.floor(rect.width - 24));
    const cssH = Math.max(240, Math.floor(rect.height - 28));
    // find bounds in mm to display: include all cabinets extents plus margin
    const arr = drawCabinets;
    let minX = Number.POSITIVE_INFINITY,
      maxX = Number.NEGATIVE_INFINITY,
      minY = Number.POSITIVE_INFINITY,
      maxY = Number.NEGATIVE_INFINITY;
    arr.forEach((c) => {
      const left = c.xMm - c.widthMm / 2;
      const right = c.xMm + c.widthMm / 2;
      const top = c.yMm - c.heightMm / 2;
      const bottom = c.yMm + c.heightMm / 2;
      minX = Math.min(minX, left);
      maxX = Math.max(maxX, right);
      minY = Math.min(minY, top);
      maxY = Math.max(maxY, bottom);
    });
    if (!isFinite(minX)) {
      minX = -SAMPLE_CABINET.widthMm / 2;
      maxX = SAMPLE_CABINET.widthMm / 2;
      minY = -SAMPLE_CABINET.heightMm / 2;
      maxY = SAMPLE_CABINET.heightMm / 2;
    }
    const totalWmm = Math.max(100, maxX - minX + MARGIN_MM * 2);
    const totalHmm = Math.max(100, maxY - minY + MARGIN_MM * 2);
    // choose scale to fit both
    const scalePxPerMm = Math.min((cssW - 40) / totalWmm, (cssH - 40) / totalHmm);
    return scalePxPerMm;
  }

  // detect if a pointer (px coords relative to canvas) hits a cabinet
  function hitTest(px: number, py: number) {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return null;
    const rect = container.getBoundingClientRect();
    const cssW = Math.max(300, Math.floor(rect.width - 24));
    const cssH = Math.max(240, Math.floor(rect.height - 28));
    const scale = computeScalePxPerMm() || 1;

    // center origin (0,0) in canvas px
    const cx = cssW / 2;
    const cy = cssH / 2;

    for (let i = drawCabinets.length - 1; i >= 0; i--) {
      const c = drawCabinets[i];
      const wPx = c.widthMm * scale;
      const hPx = c.heightMm * scale;
      const left = cx + c.xMm * scale - wPx / 2;
      const top = cy + c.yMm * scale - hPx / 2;
      if (px >= left && px <= left + wPx && py >= top && py <= top + hPx) {
        return { id: c.id, cab: c, left, top, wPx, hPx };
      }
    }
    return null;
  }

  // main draw function (keeps everything stateless)
  function draw() {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return;
    const rect = container.getBoundingClientRect();
    const cssWidth = Math.max(300, Math.floor(rect.width - 24));
    const cssHeight = Math.max(240, Math.floor(rect.height - 28));
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = `${cssWidth}px`;
    canvas.style.height = `${cssHeight}px`;
    canvas.width = Math.floor(cssWidth * dpr);
    canvas.height = Math.floor(cssHeight * dpr);
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, cssWidth, cssHeight);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, cssWidth, cssHeight);

    const scalePxPerMm = computeScalePxPerMm() || 1;
    drawGrid(ctx, cssWidth, cssHeight, scalePxPerMm);

    const cx = cssWidth / 2;
    const cy = cssHeight / 2;

    // draw each cabinet
    drawCabinets.forEach((c) => {
      const w = c.widthMm * scalePxPerMm;
      const h = c.heightMm * scalePxPerMm;
      const left = cx + c.xMm * scalePxPerMm - w / 2;
      const top = cy + c.yMm * scalePxPerMm - h / 2;
      const right = left + w;
      const bottom = top + h;

      // cabinet fill / shutter
      ctx.save();
      if (c.shutter) {
        ctx.fillStyle = "rgba(13, 71, 161, 0.06)"; // bluish shutter tint
      } else {
        ctx.fillStyle = "rgba(4,115,115,0.04)"; // light teal
      }
      roundRect(ctx, left, top, w, h, 6);
      ctx.fill();

      // outline
      ctx.lineWidth = selectedId === c.id ? 3.5 : 2.5;
      ctx.strokeStyle = selectedId === c.id ? "#004d47" : "#00796b";
      roundRect(ctx, left, top, w, h, 6);
      ctx.stroke();
      ctx.restore();

      // label
      ctx.fillStyle = "#004d47";
      ctx.font = "600 15px Inter, system-ui, 'Segoe UI', Roboto";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(`${c.widthMm} × ${c.heightMm} mm`, cx + c.xMm * scalePxPerMm, cy + c.yMm * scalePxPerMm);

      // draw shelves (each shelf is a horizontal line inside cabinet)
      if (c.shelves && c.shelves.length) {
        ctx.save();
        ctx.strokeStyle = "rgba(0,0,0,0.25)";
        ctx.lineWidth = 1.2;
        c.shelves.forEach((shelfYMm) => {
          // shelfYMm measured from top edge (mm)
          const sy = top + (shelfYMm / c.heightMm) * h;
          ctx.beginPath();
          ctx.moveTo(left + 8, sy);
          ctx.lineTo(right - 8, sy);
          ctx.stroke();
        });
        ctx.restore();
      }

      // if selected, draw small selection handles (corners)
      if (selectedId === c.id) {
        ctx.save();
        ctx.fillStyle = "#ffffff";
        ctx.strokeStyle = "#0f766e";
        ctx.lineWidth = 1.2;
        const sz = 8;
        const corners = [
          [left, top],
          [right, top],
          [right, bottom],
          [left, bottom],
        ];
        corners.forEach(([x, y]) => {
          ctx.beginPath();
          ctx.rect(x - sz / 2, y - sz / 2, sz, sz);
          ctx.fill();
          ctx.stroke();
        });
        ctx.restore();
      }

      // dimension annotation above cabinet
      ctx.save();
      ctx.fillStyle = "#333";
      ctx.font = "13px Inter, system-ui, 'Segoe UI', Roboto";
      ctx.textAlign = "center";
      ctx.fillText(`${c.widthMm} mm`, (left + right) / 2, top - 10);
      ctx.restore();
    });

    // small footer
    ctx.fillStyle = "#666";
    ctx.font = "13px Inter, system-ui, 'Segoe UI', Roboto";
    ctx.textAlign = "left";
    ctx.textBaseline = "bottom";
    ctx.fillText(`Total Cabinets: ${drawCabinets.length}  |  Total Panels: 0`, 12, cssHeight - 8);
  }

  // helper: grid
  function drawGrid(ctx: CanvasRenderingContext2D, widthPx: number, heightPx: number, scalePxPerMm: number) {
    const stepPx = GRID_STEP_MM * scalePxPerMm;
    const fineStep = stepPx / 5;
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.03)";
    for (let x = 0; x <= widthPx; x += fineStep) {
      for (let y = 0; y <= heightPx; y += fineStep) {
        if ((Math.round(x / fineStep) + Math.round(y / fineStep)) % 4 !== 0) continue;
        ctx.fillRect(x, y, 0.6, 0.6);
      }
    }
    ctx.restore();

    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,0.06)";
    ctx.beginPath();
    for (let x = 0; x <= widthPx + 0.5; x += stepPx) {
      ctx.moveTo(x, 0);
      ctx.lineTo(x, heightPx);
    }
    for (let y = 0; y <= heightPx + 0.5; y += stepPx) {
      ctx.moveTo(0, y);
      ctx.lineTo(widthPx, y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // rounded rectangle helper
  function roundRect(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, r: number) {
    ctx.beginPath();
    const radius = Math.min(r, w / 2, h / 2);
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  // draw initially (ensure canvas exists)
  useEffect(() => {
    draw();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div ref={containerRef} style={{ width: "100%", minHeight: 320, display: "flex", flexDirection: "column" }}>
      <div style={{ padding: "12px" }}>
        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <div style={{ fontSize: 18, fontWeight: 700, color: "#0f172a" }}>Design Center (Canvas)</div>
          <div style={{ fontSize: 12, color: "#6b7280" }}>Preview mode</div>
        </div>
      </div>
      <div style={{ flex: 1, padding: 12 }}>
        <canvas
          ref={canvasRef}
          style={{
            display: "block",
            width: "100%",
            height: 420,
            borderRadius: 10,
            boxShadow: "inset 0 0 0 1px rgba(15,23,42,0.04)",
            background: "linear-gradient(180deg, rgba(255,255,255,1) 0%, rgba(250,251,252,1) 100%)",
            touchAction: "none",
            cursor: "grab",
          }}
        />
      </div>
    </div>
  );
}
